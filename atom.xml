<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Stephen Aument]]></title>
  <link href="http://stephenaument.github.io/atom.xml" rel="self"/>
  <link href="http://stephenaument.github.io/"/>
  <updated>2014-03-08T01:31:28-06:00</updated>
  <id>http://stephenaument.github.io/</id>
  <author>
    <name><![CDATA[Stephen Aument]]></name>
    <email><![CDATA[saument@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Hash#fetch and Javascript]]></title>
    <link href="http://stephenaument.github.io/blog/2014/03/06/ruby-hash-dot-fetch-and-javascript/"/>
    <updated>2014-03-06T19:21:15-06:00</updated>
    <id>http://stephenaument.github.io/blog/2014/03/06/ruby-hash-dot-fetch-and-javascript</id>
    <content type="html"><![CDATA[<p>In a <a href="http://stephenaument.github.io/blog/2014/03/05/the-null-object-pattern-and-method-missing-in-ruby/">previous post</a> I mentioned a case in which I had a Haml template in a Rails app with Javascript in it. The template was rendering Ruby values into what would become a JSON object (Javascript Hash) in the browser. In that particular case, a method call on a Null Object was returning nil and breaking the Javascript.</p>

<p>Well, today I encountered another variation of this problem. In this case, I had a Ruby Hash feeding values into the JSON object. It looked like this:</p>

<div><script src='https://gist.github.com/9403295.js'></script>
<noscript><pre><code>var options = {                                                                                                                                                                                                                                                                           
  &quot;gender&quot;: &quot;#{stored_search_params[&#39;gender&#39;]}&quot;,                                                                                                                                                                                                                                          
  &quot;memberGender&quot;: &quot;#{current_user.short_gender}&quot;,                                                                                                                                                                                                                                         
  &quot;age&quot;: &quot;#{current_user.age}&quot;,                                                                                                                                                                                                                                                           
  &quot;aexcel&quot;: &quot;#{stored_search_params[&#39;aex&#39;]}&quot;,                                                                                                                                                                                                                                             
  &quot;language&quot;: &quot;#{stored_search_params[&#39;language&#39;]}&quot;,                                                                                                                                                                                                                                      
  &quot;displayLanguage&quot;: &quot;#{stored_search_params[&#39;displayLanguage&#39;]}&quot;,                                                                                                                                                                                                                        
  &quot;location&quot;: &quot;#{last_location_searched}&quot;,                                                                                                                                                                                                                                                
  &quot;radius&quot;: &quot;#{stored_search_params[&#39;radius&#39;] || default_search_radius}&quot;,                                                                                                                                                                                                                 
  &quot;query&quot;: &quot;#{stored_search_params[&#39;query&#39;]}&quot;,                                                                                                                                                                                                                                            
  &quot;accepting_new_patients&quot;: &quot;#{stored_search_params[&#39;accepting_new_patients&#39;]}&quot;,                                                                                                                                                                                                          
  &quot;procedure_id&quot;: &quot;#{stored_search_params[&#39;procedure_id&#39;]}&quot;,                                                                                                                                                                                                                              
  &quot;specialty_id&quot;: &quot;#{stored_search_params[&#39;specialty_id&#39;]}&quot;,                                                                                                                                                                                                                              
  &quot;event_properties&quot;: #{stored_search_params.fetch(&#39;event_properties&#39;, {})}                                                                                                                                                                                                               
};      </code></pre></noscript></div>


<p>Two of these fields on the ruby hash are empty: <code>language</code> and <code>properties</code>. Notice that this isn&rsquo;t a problem for most of these fields, but for one it is:</p>

<div><script src='https://gist.github.com/9404094.js'></script>
<noscript><pre><code>var options = {
  &quot;gender&quot;: &quot;M&quot;,
  &quot;age&quot;: &quot;27&quot;,
  &quot;language&quot;: &quot;en-US&quot;,
  &quot;query&quot;: &quot;specials&quot;,
  &quot;properties&quot;: 
};</code></pre></noscript></div>


<p>See that? The first four fields feed into double quotes as strings. If they are empty, they are empty. It may cause an issue somewhere down the line, but the Javascript itself is valid.</p>

<p>The <code>properties</code> field, on the other hand is expecting a JSON object. That missing bit will cause Javascript to blow up once this loads in the browser.</p>

<p>What&rsquo;s the solution here? In this case, I turned to <code>Hash#fetch</code> rather than the <code>[]</code> accessor. What&rsquo;s the difference? There are two main differences between the bracket accessor and the <code>fetch</code> method. First, <code>my_hash[:some_missing_key]</code> will return <code>nil</code> if the key is not found in the hash. If <code>my_hash.fetch(:some_missing_key)</code> can&rsquo;t find a key, it will raise a <code>KeyError</code> exception.</p>

<p>That&rsquo;s not really what we are looking for, which brings me to the second difference. <code>Hash#fetch</code> takes an optional second argument which specifies a default value. So if we call <code>my_hash.fetch(:some_missing_key, 'tacos')</code> and the key is not found in the hash, it will return <code>'tacos'</code> instead of <code>nil</code>. That&rsquo;s exactly what I needed. I returned an empty JSON object <code>{}</code> as the default.</p>

<div><script src='https://gist.github.com/9404014.js'></script>
<noscript><pre><code>var options = {                                                                                                                                                                                                                                                                           
  &quot;gender&quot;: &quot;#{search_params[&#39;gender&#39;]}&quot;,                                                                                                                                                                                                                                          
  &quot;age&quot;: &quot;#{current_user.age}&quot;,                                                                                                                                                                                                                                                           
  &quot;language&quot;: &quot;#{search_params[&#39;language&#39;]}&quot;,                                                                                                                                                                                                                                      
  &quot;query&quot;: &quot;#{search_params[&#39;query&#39;]}&quot;,                                                                                                                                                                                                                                            
  &quot;properties&quot;: #{search_params.fetch(&#39;properties&#39;, {})}                                                                                                                                                                                                               
};</code></pre></noscript></div>


<p>This degraded nicely in the cases in which I had no <code>properties</code> hash in my <code>search_params</code> hash.</p>

<div><script src='https://gist.github.com/9404101.js'></script>
<noscript><pre><code>var options = {
  &quot;gender&quot;: &quot;M&quot;,
  &quot;age&quot;: &quot;27&quot;,
  &quot;language&quot;: &quot;en-US&quot;,
  &quot;query&quot;: &quot;specials&quot;,
  &quot;properties&quot;: {}
};</code></pre></noscript></div>


<p>No more broken Javascript.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Null Object Pattern and method_missing in Ruby]]></title>
    <link href="http://stephenaument.github.io/blog/2014/03/05/the-null-object-pattern-and-method-missing-in-ruby/"/>
    <updated>2014-03-05T23:01:09-06:00</updated>
    <id>http://stephenaument.github.io/blog/2014/03/05/the-null-object-pattern-and-method-missing-in-ruby</id>
    <content type="html"><![CDATA[<p>I encountered an interesting problem this week that allowed me to dig into the Null Object pattern, Ruby duck typing, and Ruby&rsquo;s method_missing.</p>

<p>In our app we have a <code>Duck</code> class (name changed to protect the innocent). Most of our users have a <code>Duck</code> associated with their account, but some don&rsquo;t. In our application, we have certain situations which expect a Duck, even if the user doesn&rsquo;t have one. If we don&rsquo;t have a Duck, but our app expects one and passes it a message like <code>quack,</code> we will receive an ugly <code>NoMethodError: undefined method 'quack' for nil:NilClass</code> error.</p>

<p>How can we solve this without spreading smelly nil checks around our system? It turns out there is an existing design pattern for just this situation, the Null Object pattern. In the Null Object pattern, we create a stand in object for our <code>Duck</code> that can respond to the same interface, but without returning any values. We avoid ugly <code>NoMethodError</code>s without having to check for the objects existence everywhere.</p>

<p>Here is our Duck:</p>

<div><script src='https://gist.github.com/9426713.js?file=duck1.rb'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>This is a Ruby on Rails ActiveRecord model, so there is more to it than we see here. Here is the database migration file:</p>

<div><script src='https://gist.github.com/9426713.js?file=create_ducks_migration1.rb'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>For each of these fields, ActiveRecord will create getter and setter methods in the background. But for the <code>migratory</code> boolean field, we will get the bonus <code>migratory?</code> predicate method.</p>

<p>In our case, it turned out that we need our <code>NilDuck</code> to return <em>some</em> values, but most things should just return <code>nil</code>. The simplest way for us to implement our <code>NilDuck</code>, and the state in which I found my <code>NilDuck</code> code this week looks something like the following:</p>

<div><script src='https://gist.github.com/9426713.js?file=nil_duck1.rb'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>Here we have provided the attribute setters our fake object needs with the <code>attr_writer</code> call. We then proceed to override each getter as needed. There are a few special cases in which a value other than nil is desired, but the default return value for our <code>NilDuck</code> is <code>nil</code>. In the cases in which we don&rsquo;t have an actual <code>Duck</code> and need to use a demo <code>Duck</code>, we can pass in an instance of our <code>NilDuck</code> and everything will work as expected.</p>

<blockquote><p>Note: since Ruby is not a strongly typed language, we don&rsquo;t have to subclass our <code>Duck</code> here or implement a formal common interface as we would in a strongly-typed language like Java. In Rubyland, types are determined by the public interface of the object in question. So if our <code>NilDuck</code>, or any other object for that matter, implements the methods our client object calls in <code>Duck</code>, we can substitute it. This is often called &ldquo;duck typing,&rdquo; since if an object quacks like a duck, and acts like a duck, we can usually consider it a duck. We <em>do</em> implement a common interface, but the interface that we implement is conceptual, represented by the messages to which we expect our duck to respond. It&rsquo;s not baked into the language as a formal construct.</p></blockquote>

<p>So what&rsquo;s wrong with this code? Nothing at face value. Maybe it could be refactored into something less verbose, but it&rsquo;s functional and fairly straightforward. In the beginning it served our app quite well. But I came to this code last week because of a bug uncovered by a change in another area of the app. It turned out that my <code>NilDuck</code> code had gotten stale and not kept up with changes to the <code>Duck</code> class. Methods had been added to <code>Duck</code>, but not to <code>NilDuck</code>. Now <code>Duck</code> looks like this:</p>

<div><script src='https://gist.github.com/9426713.js?file=duck2.rb'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>And the migration:</p>

<div><script src='https://gist.github.com/9426713.js?file=create_ducks_migration2.rb'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>We don&rsquo;t have equivalent <code>secondary_color</code> and  <code>multi_colored?</code> methods and our NilDuck started causing errors. Since none of these new methods requirs special values, I could have just added equivalent getters in NilDuck that returned <code>nil</code>. But since I&rsquo;m a lazy programmer, I asked myself how I could avoid editing this class in the future. I turned to Ruby&rsquo;s <code>method_missing</code>!</p>

<p>In order to understand what my pair and I did here, you need to understand a little about the way Ruby looks up a method, or message, passed to an object. When you call a method on a Ruby object, Ruby first looks to see if the method has been defined on the object instance itself (or more precisely on it&rsquo;s <a href="http://en.wikipedia.org/wiki/Metaclass">eigenclass</a>), if it doesn&rsquo;t find it it will then look in any included modules in reverse include order, then in the instance methods of the class, and finally in the instance methods of the <code>Object</code> class, the ultimate ancestor of every object in Ruby. If Ruby still can&rsquo;t find the method, it starts the search over at our instance, this time trying to call <code>method_missing</code>. If it can&rsquo;t find a definition for <code>method_missing</code> somewhere in our inheritance chain, only then will it throw a <code>NoMethodError</code>.</p>

<p>The <code>method_missing</code> callback gives us the hook we need to handle our, well, missing methods. Let&rsquo;s refactor our <code>NilDuck</code> to use <code>method_missing</code>:</p>

<div><script src='https://gist.github.com/9426713.js?file=nil_duck2.rb'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>See what we did there? We want <code>NilDuck</code> to have the same interface as <code>Duck</code>, so in our <code>method_missing</code> implementation, we first checked to see whether <code>Duck</code> responds to the method our client code attempted to call. If it does, we return <code>nil</code>, otherwise we pass the buck to super. Our <code>NilDuck</code> will now respond to everything that <code>Duck</code> responds to and throw a <code>NoMethodError</code> for anything that it doesn&rsquo;t respond to. As a bonus, we got to eliminate a lot of code here.</p>

<p>But what about predicate methods? Well, in Ruby, <code>nil</code> is falsey, so this code will work correctly in an <code>if/unless/!</code> situation, but what about a situation in which you might need <code>migratory?</code> to explicitly give you <code>false</code> instead of <code>nil</code>? What if you are going to pass that <code>true</code> or <code>false</code> along to someone else as a string? What if you need to feed it into javascript from an erb or haml template?</p>

<div><script src='https://gist.github.com/9426713.js?file=javascript.js.rb'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>If this <code>duck</code> is our <code>NilDuck</code>, <code>duck.multi_colored?</code> will return <code>nil</code>. When the template is rendered and the string is interpolated, <code>nil</code>&rsquo;s <code>to_s</code> method will be invoked, which will return an empty string instead of <code>'false'</code>. This will result in a javascript error in the browser:</p>

<div><script src='https://gist.github.com/9426713.js?file=javascript1.js'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>Whoops! That&rsquo;s not what we wanted at all! We want <code>'true'</code> or <code>'false'</code> to be rendered. How can we handle that? Well, we can fall back and explicitly create a <code>multi_colored?</code> method in our <code>NilDuck</code> that returns <code>false</code>, but we can do better than that. Let&rsquo;s stay lazy so we don&rsquo;t have to fix this again! Since it turns out that we don&rsquo;t really want our predicate methods to return just a falsey value, but <code>false</code> itself. Let&rsquo;s account for that:</p>

<div><script src='https://gist.github.com/9426713.js?file=nil_duck3.rb'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>Now if <code>Duck</code> responds to our method and our method ends with &lsquo;?&rsquo;, <code>NilDuck</code> will return <code>false</code>, if it doesn&rsquo;t end with &lsquo;?&rsquo; it will return <code>nil</code>. Our template will now render the javascript we expected:</p>

<div><script src='https://gist.github.com/9426713.js?file=javascript2.js'></script>
<noscript><pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end</code></pre></noscript></div>


<p>You could certainly take this further and abstract out a generic <code>NilObject</code> for your app, but this serves our needs quite well. For further reading on the Null Object pattern: [<a href="http://devblog.avdi.org/2011/05/30/null-objects-and-falsiness/">http://devblog.avdi.org/2011/05/30/null-objects-and-falsiness/</a>]</p>
]]></content>
  </entry>
  
</feed>
