<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Stephen Aument]]></title>
  <link href="http://stephenaument.github.io/atom.xml" rel="self"/>
  <link href="http://stephenaument.github.io/"/>
  <updated>2014-03-05T23:39:07-06:00</updated>
  <id>http://stephenaument.github.io/</id>
  <author>
    <name><![CDATA[Stephen Aument]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Null Object Pattern and Method_missing in Ruby]]></title>
    <link href="http://stephenaument.github.io/blog/2014/03/05/the-null-object-pattern-and-method-missing-in-ruby/"/>
    <updated>2014-03-05T23:01:09-06:00</updated>
    <id>http://stephenaument.github.io/blog/2014/03/05/the-null-object-pattern-and-method-missing-in-ruby</id>
    <content type="html"><![CDATA[<p>I encountered an interesting problem this week that allowed me to dig into the Null Object pattern, Ruby duck typing, and Ruby&rsquo;s method_missing.</p>

<p>In our app we have a <code>Duck</code> class (name changed to protect the innocent). Most of our users have a <code>Duck</code> associated with their account, but some don&rsquo;t. In our application, we have certain situations which expect a Duck, even if the user doesn&rsquo;t have one. If we don&rsquo;t have a Duck, but our app expects one and passes it a message like <code>quack,</code> we will receive an ugly <code>NoMethodError: undefined method 'quack' for nil:NilClass</code> error.</p>

<p>How can we solve this without spreading smelly nil checks around our system? It turns out there is an existing design pattern for just this situation, the Null Object pattern. In the Null Object pattern, we create a stand in object for our <code>Duck</code> that can respond to the same interface, but without returning any values. We avoid ugly <code>NoMethodError</code>s without having to check for the objects existence everywhere.</p>

<p>Here is our Duck:</p>

<pre><code>class Duck &lt; ActiveRecord::Base
  def awake?
    status == 'awake'
  end


  def quack
    puts quack_style
  end
end
</code></pre>

<p>This is a Ruby on Rails ActiveRecord model, so there is more to it than we see here. Here is the database migration file:</p>

<pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.migratory boolean
  end
end
</code></pre>

<p>For each of these fields, ActiveRecord will create getter and setter methods in the background. But for the <code>migratory</code> boolean field, we will get the bonus <code>migratory?</code> predicate method.</p>

<p>In our case, it turned out that we need our <code>NilDuck</code> to return <em>some</em> values, but most things should just return <code>nil</code>. The simplest way for us to implement our <code>NilDuck</code>, and the state in which I found my <code>NilDuck</code> code this week looks something like the following:</p>

<pre><code>class NilDuck
  attr_writer :name, :status, :hunger, :quack_style, :color, :migratory


  def name
    'Demo Duck'
  end


  def status
    'sleeping'
  end


  def hunger
    nil
  end


  def quack
  end


  def quack_style
    nil
  end


  def color
    'gray'
  end


  def awake?
    false
  end


  def migratory
    nil
  end


  def migratory?
    true
  end
end
</code></pre>

<p>Here we have provided the attribute setters our fake object needs with the <code>attr_writer</code> call. We then proceed to override each getter as needed. There are a few special cases in which a value other than nil is desired, but the default return value for our <code>NilDuck</code> is <code>nil</code>. In the cases in which we don&rsquo;t have an actual <code>Duck</code> and need to use a demo <code>Duck</code>, we can pass in an instance of our <code>NilDuck</code> and everything will work as expected.</p>

<blockquote><p>Note: since Ruby is not a strongly typed language, we don&rsquo;t have to subclass our <code>Duck</code> here or implement a formal common interface as we would in a strongly-typed language like Java. In Rubyland, types are determined by the public interface of the object in question. So if our <code>NilDuck</code>, or any other object for that matter, implements the methods our client object calls in <code>Duck</code>, we can substitute it. This is often called &ldquo;duck typing,&rdquo; since if an object quacks like a duck, and acts like a duck, we can usually consider it a duck. We <em>do</em> implement a common interface, but the interface that we implement is conceptual, represented by the messages to which we expect our duck to respond. It&rsquo;s not baked into the language as a formal construct.</p></blockquote>

<p>So what&rsquo;s wrong with this code? Nothing at face value. Maybe it could be refactored into something less verbose, but it&rsquo;s functional and fairly straightforward. In the beginning it served our app quite well. But I came to this code last week because of a bug uncovered by a change in another area of the app. It turned out that my <code>NilDuck</code> code had gotten stale and not kept up with changes to the <code>Duck</code> class. Methods had been added to <code>Duck</code>, but not to <code>NilDuck</code>. Now <code>Duck</code> looks like this:</p>

<pre><code>class Duck &lt; ActiveRecord::Base
  def awake?
    status == 'awake'
  end


  def multi_colored?
    !secondary_color.nil?
  end
end
</code></pre>

<p>And the migration:</p>

<pre><code>class CreateDucks &lt; ActiveRecord::Migration
  def change
    t.string name
    t.string status
    t.integer hunger
    t.string quack_style
    t.string color
    t.string secondary_color
    t.migratory boolean
  end
end
</code></pre>

<p>We don&rsquo;t have equivalent <code>secondary_color</code> and  <code>multi_colored?</code> methods and our NilDuck started causing errors. Since none of these new methods requirs special values, I could have just added equivalent getters in NilDuck that returned <code>nil</code>. But since I&rsquo;m a lazy programmer, I asked myself how I could avoid editing this class in the future. I turned to Ruby&rsquo;s <code>method_missing</code>!</p>

<ul>
<li>Ruby class inheritance and method_missing</li>
</ul>


<p>In order to understand what my pair and I did here, you need to understand a little about the way Ruby looks up a method, or message, passed to an object. When you call a method on a Ruby object, Ruby first looks to see if the method has been defined on the object instance itself (or more precisely on it&rsquo;s <a href="http://en.wikipedia.org/wiki/Metaclass">eigenclass</a>), if it doesn&rsquo;t find it it will then look in any included modules in reverse include order, then in the instance methods of the class, and finally in the instance methods of the <code>Object</code> class, the ultimate ancestor of every object in Ruby. If Ruby still can&rsquo;t find the method, it starts the search over at our instance, this time trying to call <code>method_missing</code>. If it can&rsquo;t find a definition for <code>method_missing</code> somewhere in our inheritance chain, only then will it throw a <code>NoMethodError</code>.</p>

<ul>
<li>Using method_missing as a Catch-all for Methods Implemented in the Original.</li>
</ul>


<p>The <code>method_missing</code> callback gives us the hook we need to handle our, well, missing methods. Let&rsquo;s refactor our <code>NilDuck</code> to use <code>method_missing</code>:</p>

<pre><code>class NilDuck
  def name
    'Demo Duck'
  end


  def status
    'sleeping'
  end


  def color
    'gray'
  end


  def migratory?
    true
  end


  def method_missing(name, *args)
    Duck.new.respond_to?(name) ? nil : super
  end
end
</code></pre>

<p>See what we did there? We want <code>NilDuck</code> to have the same interface as <code>Duck</code>, so in our <code>method_missing</code> implementation, we first checked to see whether <code>Duck</code> responds to the method our client code attempted to call. If it does, we return <code>nil</code>, otherwise we pass the buck to super. Our <code>NilDuck</code> will now respond to everything that <code>Duck</code> responds to and throw a <code>NoMethodError</code> for anything that it doesn&rsquo;t respond to. As a bonus, we got to eliminate a lot of code here.</p>

<p>But what about predicate methods? Well, in Ruby, <code>nil</code> is falsey, so this code will work correctly in an <code>if/unless/!</code> situation, but what about a situation in which you might need <code>migratory?</code> to explicitly give you <code>false</code> instead of <code>nil</code>? What if you are going to pass that <code>true</code> or <code>false</code> along to someone else as a string? What if you need to feed it into javascript from an erb or haml template?</p>

<pre><code>// javascript
{ multiColored: #{duck.multi_colored?} }
</code></pre>

<p>If this <code>duck</code> is our <code>NilDuck</code>, <code>duck.multi_colored?</code> will return <code>nil</code>. When the template is rendered and the string is interpolated, <code>nil</code>&rsquo;s <code>to_s</code> method will be invoked, which will return an empty string instead of <code>'false'</code>. This will result in a javascript error in the browser:</p>

<pre><code>// javascript
{ multiColored: } // !!! Not a valid JSON object, buddy!
</code></pre>

<p>Whoops! That&rsquo;s not what we wanted at all! We want <code>'true'</code> or <code>'false'</code> to be rendered. How can we handle that? Well, we can fall back and explicitly create a <code>multi_colored?</code> method in our <code>NilDuck</code> that returns <code>false</code>, but we can do better than that. Let&rsquo;s stay lazy so we don&rsquo;t have to fix this again! Since it turns out that we don&rsquo;t really want our predicate methods to return just a falsey value, but <code>false</code> itself. Let&rsquo;s account for that:</p>

<pre><code>class NilDuck
  def name
    'Demo Duck'
  end


  def status
    'sleeping'
  end


  def color
    'gray'
  end


  def migratory?
    true
  end


  def method_missing(name, *args)
    super unless Duck.new.respond_to?(name)
    name.ends_with?('?') ? false : nil
  end
end
</code></pre>

<p>Now if <code>Duck</code> responds to our method and our method ends with &lsquo;?&rsquo;, <code>NilDuck</code> will return <code>false</code>, if it doesn&rsquo;t end with &lsquo;?&rsquo; it will return <code>nil</code>. Our template will now render the javascript we expected:</p>

<pre><code>// javascript
{ multiColored: false }
</code></pre>

<p>You could certainly take this further and abstract out a generic <code>NilObject</code> for your app, but this serves our needs quite well. For further reading on the Null Object pattern: [<a href="http://devblog.avdi.org/2011/05/30/null-objects-and-falsiness/">http://devblog.avdi.org/2011/05/30/null-objects-and-falsiness/</a>]</p>
]]></content>
  </entry>
  
</feed>
